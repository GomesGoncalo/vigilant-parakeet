<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Network Viz</title>
    <!-- Instruct Trunk to build the specific Rust binary artifact named 'visualization' -->
    <link data-trunk rel="rust" data-bin="visualization" />
        <script src="https://unpkg.com/cytoscape@3.24.0/dist/cytoscape.min.js"></script>
        <!-- inlined cy_interop.js to avoid dev-server path returning index HTML -->
        <script>
        // Minimal Cytoscape interop for VP (inlined)
        // Exposes window.__vp_render_graph(nodes, edges)
        console.log('[VP-CY] cy_interop (inlined) loaded');
        (function(){
            function ensureCy() {
                if (window.__vp_cy_instance) {
                    try { console.debug('[VP-CY] reusing cy instance'); } catch (e) {}
                    return window.__vp_cy_instance;
                }
                const container = document.getElementById('graph');
                if (!container) return null;
                let root = document.getElementById('__vp_cy_root');
                if (!root) {
                    root = document.createElement('div');
                    root.id = '__vp_cy_root';
                    Object.assign(root.style, { position: 'absolute', inset: '0px', width: '100%', height: '100%', pointerEvents: 'auto', zIndex: 99999, background: 'transparent' });
                    const cs = getComputedStyle(container);
                    if (!cs || cs.position === 'static' || !cs.position) container.style.position = 'relative';
                    container.appendChild(root);
                }
                const cy = cytoscape({
                    container: root,
                    elements: [],
                    style: [
                        { selector: 'node', style: { 'label': 'data(label)', 'text-valign': 'center', 'text-halign': 'center', 'background-color': 'data(color)', 'width': 'data(size)', 'height': 'data(size)', 'font-size': 10 } },
                        { selector: 'edge', style: { 'curve-style': 'bezier', 'target-arrow-shape': 'triangle', 'target-arrow-color': 'data(color)', 'line-color': 'data(color)', 'width': 'data(width)', 'opacity': 0.95 } },
                        // upstream-highlight class forces orange for immediate-upstream edges (placed after 'edge' to take precedence)
                        { selector: 'edge.upstream', style: { 'line-color': '#ff7f0e', 'target-arrow-color': '#ff7f0e', 'opacity': 1 } },
                        { selector: 'edge.downstream', style: { 'line-color': '#1f77b4', 'target-arrow-color': '#1f77b4', 'opacity': 1 } }
                    ],
                    layout: { name: 'preset' },
                });
                try { console.debug('[VP-CY] created cytoscape instance'); } catch (e) {}
                try {
                    window.__vp_user_positions = window.__vp_user_positions || {};
                    try { cy.on('free', 'node', (ev) => { try { const n = ev.target; window.__vp_user_positions[n.id()] = n.position(); } catch (e) {} }); } catch (e) {}
                } catch (e) {}
                window.__vp_cy_instance = cy;
                try { window.__vp_cy_drag_attached = false; } catch (e) {}
                return cy;
            }

            window.__vp_render_graph = function(nodes, edges) {
                try {
                    const cy = ensureCy();
                    if (!cy) return;
                    try { window.__vp_last_nodes = Array.isArray(nodes) ? nodes.slice() : []; window.__vp_last_edges = Array.isArray(edges) ? edges.slice() : []; } catch (e) {}

                    const nodeList = Array.isArray(nodes) ? nodes : [];
                    const edgeList = Array.isArray(edges) ? edges : [];
                    const seenNodeIds = new Set();
                    const seenEdgeIds = new Set();

                    for (const n of nodeList) {
                        const id = n && (n.id || n.label);
                        if (!id) continue;
                        seenNodeIds.add(String(id));
                        const x = (typeof n.x === 'number') ? n.x*100 : 0;
                        const y = (typeof n.y === 'number') ? -n.y*100 : 0;
                        const color = n && n.type && typeof n.type === 'string' && n.type.toLowerCase() === 'rsu' ? 'rgba(200,30,30,0.95)' : 'rgba(30,100,200,0.95)';
                        const size = Math.max(8, Number(n.size) || 12);
                        const existing = cy.getElementById(String(id));
                        const userPos = window.__vp_user_positions && window.__vp_user_positions[String(id)];
                        if (existing && existing.length > 0) {
                            existing.data(Object.assign({}, existing.data(), { label: n.label, color: color, size: size }));
                            try { console.debug('[VP-CY] node updated (kept position)', String(id), !!(window.__vp_user_positions && window.__vp_user_positions[String(id)])); } catch (e) {}
                        } else {
                            const pos = userPos ? userPos : { x: x, y: y };
                            try { cy.add({ group: 'nodes', data: { id: String(id), label: n.label, color: color, size: size }, position: pos }); try { console.debug('[VP-CY] node added', String(id), 'posFrom', userPos ? 'user' : 'payload', pos); } catch (e) {} } catch (e) { console.debug('[VP-CY] add node failed', id, e); }
                        }
                    }

                    const getVal = (obj, keys) => {
                        if (!obj) return undefined;
                        for (const k of keys) {
                            try { if (typeof obj.get === 'function') { const v = obj.get(k); if (typeof v !== 'undefined' && v !== null) return v; } } catch (e) {}
                            try { if (Object.prototype.hasOwnProperty.call(obj, k)) return obj[k]; } catch (e) {}
                        }
                        return undefined;
                    };

                    // Precompute totals and find max so we can scale relative to the heaviest current route
                    const edgeTotals = [];
                    for (const rawE of edgeList) {
                        let e = rawE;
                        try {
                            if (e && typeof e.entries === 'function') {
                                const tmp = {};
                                for (const kv of e.entries()) { try { tmp[String(kv[0])] = kv[1]; } catch (ee) {} }
                                e = tmp;
                            }
                        } catch (ee) {}
                        const up = Number(getVal(e, ['up_bps', 'up'])) || 0;
                        const down = Number(getVal(e, ['down_bps', 'down'])) || 0;
                        edgeTotals.push(Math.max(0, up) + Math.max(0, down));
                    }
                    const maxTotal = edgeTotals.length ? Math.max(...edgeTotals) : 0;

                    for (let ei = 0; ei < edgeList.length; ei++) {
                        const rawE = edgeList[ei];
                        let e = rawE;
                        try {
                            if (e && typeof e.entries === 'function') {
                                const tmp = {};
                                for (const kv of e.entries()) { try { tmp[String(kv[0])] = kv[1]; } catch (ee) {} }
                                e = tmp;
                            }
                        } catch (ee) {}

                        const src = getVal(e, ['source', 'from', 'src']);
                        const tgt = getVal(e, ['target', 'to', 'dst']);
                        if (!src || !tgt) { console.debug('[VP-CY] skipping malformed edge', e); continue; }
                        const edgeId = getVal(e, ['id']) || (String(src) + '->' + String(tgt));
                        seenEdgeIds.add(String(edgeId));
                        const up = Number(getVal(e, ['up_bps', 'up'])) || 0;
                        const down = Number(getVal(e, ['down_bps', 'down'])) || 0;
                        let bw;
                        try {
                            // Only accept an explicit provided width if the page explicitly allows it.
                            const useProvided = !!window.__vp_use_provided_width;
                            const provided = useProvided ? (getVal(e, ['width', 'w']) || (e && e.width)) : undefined;
                            const maybeNum = (typeof provided === 'number') ? provided : (typeof provided === 'string' && provided && provided.match(/^-?\d+(?:\.\d+)?$/) ? Number(provided) : NaN);
                            if (!Number.isNaN(maybeNum)) {
                                bw = Math.max(1, Math.min(20, Math.round(maybeNum)));
                            } else {
                                const total = edgeTotals[ei] || 0;
                                if (total <= 0 || maxTotal <= 0) {
                                    bw = 1;
                                } else {
                                    // scale linearly relative to the maximum total in this payload
                                    const frac = Math.max(0, Math.min(1, total / maxTotal));
                                    const min_w = 1.0;
                                    const max_w = 20.0;
                                    bw = Math.max(1, Math.min(20, Math.round(min_w + (frac * (max_w - min_w)))));
                                }
                            }
                        } catch (e) { bw = 1; }
                        // Optional debug logging per-edge to diagnose saturation
                        try {
                            if (window.__vp_edge_debug) {
                                try { window.__vp_edge_debug_out = window.__vp_edge_debug_out || []; } catch (e) {}
                                const total = edgeTotals[ei] || 0;
                                const frac = maxTotal > 0 ? Math.max(0, Math.min(1, total / maxTotal)) : 0;
                                try { console.debug('[VP-CY] edge-debug', edgeId, { total: total, maxTotal: maxTotal, frac: frac, bw: bw }); } catch (e) {}
                                try { window.__vp_edge_debug_out.push({ id: edgeId, total: total, maxTotal: maxTotal, frac: frac, bw: bw }); } catch (e) {}
                            }
                        } catch (ee) {}
                        let arrowScale = 1.0;
                        try {
                            // Map bw [1..20] -> arrow scale range. Increase range so arrowheads are visually distinct.
                            const frac = (Math.max(1, bw) - 1) / (20 - 1);
                            // Wider arrow-scale range: small routes ~0.9x, heavy routes ~1.5x
                            const minA = 0.9, maxA = 1.5;
                            arrowScale = Math.max(minA, Math.min(maxA, minA + frac * (maxA - minA)));
                        } catch (e) { arrowScale = 1.0; }
                        // Compute visual width (allow runtime tuning via window.__vp_edge_visual_scale)
                        let visualWidth = bw;
                        try {
                            if (typeof window.__vp_edge_visual_scale !== 'number') window.__vp_edge_visual_scale = 2.0;
                            const scale = Math.max(0.1, Number(window.__vp_edge_visual_scale) || 1.0);
                            visualWidth = Math.max(1, Math.round(bw * scale));
                        } catch (e) { visualWidth = bw; }
                        const colorVal = getVal(e, ['color']) || (up > down ? 'rgba(200,30,30,0.9)' : (down > up ? 'rgba(30,100,200,0.9)' : 'rgba(120,120,120,0.6)'));
                        let color = String(colorVal);
                        try {
                            const rk = getVal(e, ['route_kind', 'routeKind', 'kind']);
                            if (rk && String(rk).toLowerCase() === 'upstream') {
                                color = '#ff7f0e';
                            }
                        } catch (e) {}
                        try {
                            // Prefer explicit runtime-provided node_info if available
                            const maybeNodeInfo = window.__vp_node_info || window.__vp_last_node_info || null;
                            const srcStr = String(src);
                            const tgtStr = String(tgt);
                            let isImmediateUp = false;
                            try {
                                if (maybeNodeInfo && typeof maybeNodeInfo === 'object') {
                                    // support Map-like and plain object shapes
                                    const v = (typeof maybeNodeInfo.get === 'function') ? maybeNodeInfo.get(srcStr) : maybeNodeInfo[srcStr];
                                    if (v) {
                                        // get upstream map or object
                                        let upv = undefined;
                                        if (typeof v.get === 'function') {
                                            upv = v.get('upstream');
                                        } else if (v.upstream) {
                                            upv = v.upstream;
                                        }
                                        if (upv) {
                                            let un = undefined;
                                            if (typeof upv.get === 'function') {
                                                un = upv.get('node_name') || upv.get('nodeName') || upv.get('node');
                                            } else if (upv.node_name || upv.nodeName || upv.node) {
                                                un = upv.node_name || upv.nodeName || upv.node;
                                            }
                                            if (typeof un !== 'undefined' && String(un) === tgtStr) isImmediateUp = true;
                                        }
                                    }
                                }
                            } catch (e) {}
                            // Fallback: inspect last_nodes snapshot (wasm sometimes stores Maps)
                            if (!isImmediateUp && Array.isArray(window.__vp_last_nodes)) {
                                for (const n of window.__vp_last_nodes) {
                                    try {
                                        // support Map-like nodes
                                        const nid = (n && typeof n.get === 'function') ? (n.get('id') || n.get('label')) : (n && (n.id || n.label));
                                        if (!nid) continue;
                                        if (String(nid) !== srcStr) continue;
                                        // get upstream from node entry
                                        let up = undefined;
                                        if (n && typeof n.get === 'function') {
                                            const upmap = n.get('upstream');
                                            if (upmap) up = (typeof upmap.get === 'function') ? (upmap.get('node_name') || upmap.get('nodeName') || upmap.get('node')) : (upmap && (upmap.node_name || upmap.nodeName || upmap.node));
                                        } else {
                                            up = (n && n.upstream && (n.upstream.node_name || n.upstream.nodeName || n.upstream.node)) || undefined;
                                        }
                                        if (typeof up !== 'undefined' && String(up) === tgtStr) { isImmediateUp = true; break; }
                                    } catch (e) {}
                                }
                            }
                            if (isImmediateUp) color = '#ff7f0e';
                        } catch (e) {}
                        const existingE = cy.getElementById(String(edgeId));
                        try {
                            if (!cy.getElementById(String(src)).length) {
                                const userPosSrc = window.__vp_user_positions && window.__vp_user_positions[String(src)];
                                const posSrc = userPosSrc ? userPosSrc : { x: 0, y: 0 };
                                try { cy.add({ group: 'nodes', data: { id: String(src), label: String(src), color: 'rgba(120,120,120,0.9)', size: 12 }, position: posSrc }); } catch (e) { console.debug('[VP-CY] add placeholder src failed', src, e); }
                                try { seenNodeIds.add(String(src)); } catch (e) {}
                            }
                            if (!cy.getElementById(String(tgt)).length) {
                                const userPosTgt = window.__vp_user_positions && window.__vp_user_positions[String(tgt)];
                                const posTgt = userPosTgt ? userPosTgt : { x: 0, y: 0 };
                                try { cy.add({ group: 'nodes', data: { id: String(tgt), label: String(tgt), color: 'rgba(120,120,120,0.9)', size: 12 }, position: posTgt }); } catch (e) { console.debug('[VP-CY] add placeholder tgt failed', tgt, e); }
                                try { seenNodeIds.add(String(tgt)); } catch (e) {}
                            }
                        } catch (e) {}
                        if (existingE && existingE.length > 0) {
                            try { existingE.data(Object.assign({}, existingE.data(), { width: bw, arrow_scale: arrowScale, color: color, source: String(src), target: String(tgt), __vp_total: (Math.max(0, up) + Math.max(0, down)), __vp_bw: bw, __vp_visual: visualWidth })); } catch (e) {}
                            try { existingE.style('width', visualWidth); } catch (e) {}
                            try { existingE.style('arrow-scale', arrowScale); } catch (e) {}
                            try { existingE.style('line-color', color); } catch (e) {}
                            try { existingE.style('target-arrow-color', color); } catch (e) {}
                            try {
                                // toggle upstream/downstream classes for stylesheet override
                                const rk_val = getVal(e, ['route_kind','routeKind','kind']);
                                const isUp = (rk_val && String(rk_val).toLowerCase() === 'upstream') || isImmediateUp;
                                const isDown = (rk_val && String(rk_val).toLowerCase() === 'downstream') || false; // downstream detection via node_info not currently used
                                if (isUp) { try { console.debug('[VP-CY] marking upstream edge', String(edgeId)); } catch (ee) {} existingE.addClass('upstream'); } else existingE.removeClass('upstream');
                                if (isDown) { try { console.debug('[VP-CY] marking downstream edge', String(edgeId)); } catch (ee) {} existingE.addClass('downstream'); } else existingE.removeClass('downstream');
                                // Fallback: if coloring was applied but class toggle missed, detect by color and add appropriate class
                                try {
                                    const col = String(color || '').toLowerCase();
                                    // orange (#ff7f0e) or rgb(255,127,14)
                                    if (!existingE.hasClass('upstream') && (col.includes('ff7f0e') || col.includes('255,127,14'))) { try { console.debug('[VP-CY] fallback-mark upstream by color', String(edgeId), col); } catch (ee) {} existingE.addClass('upstream'); }
                                    // blue (#1f77b4) or rgb(31,119,180)
                                    if (!existingE.hasClass('downstream') && (col.includes('1f77b4') || col.includes('31,119,180') || col.includes('30,119,180'))) { try { console.debug('[VP-CY] fallback-mark downstream by color', String(edgeId), col); } catch (ee) {} existingE.addClass('downstream'); }
                                } catch (ee) {}
                            } catch (ee) {}
                        } else {
                            try { cy.add({ group: 'edges', data: { id: String(edgeId), source: String(src), target: String(tgt), width: bw, arrow_scale: arrowScale, color: color } });
                                const newE = cy.getElementById(String(edgeId));
                                try { if (newE && newE.length) newE.data({ __vp_total: (Math.max(0, up) + Math.max(0, down)), __vp_bw: bw, __vp_visual: visualWidth }); } catch (e) {}
                                try { if (newE && newE.length) newE.style('width', visualWidth); } catch (e) {}
                                try { if (newE && newE.length) newE.style('arrow-scale', arrowScale); } catch (e) {}
                                try { if (newE && newE.length) newE.style('line-color', color); } catch (e) {}
                                try { if (newE && newE.length) newE.style('target-arrow-color', color); } catch (e) {}
                                try {
                                    const rk_val = getVal(e, ['route_kind','routeKind','kind']);
                                    const isUp = (rk_val && String(rk_val).toLowerCase() === 'upstream') || isImmediateUp;
                                    const isDown = (rk_val && String(rk_val).toLowerCase() === 'downstream') || false;
                                    if (newE && newE.length) { if (isUp) { try { console.debug('[VP-CY] adding upstream edge', String(edgeId)); } catch (ee) {} newE.addClass('upstream'); } else newE.removeClass('upstream'); }
                                    if (newE && newE.length) { if (isDown) { try { console.debug('[VP-CY] adding downstream edge', String(edgeId)); } catch (ee) {} newE.addClass('downstream'); } else newE.removeClass('downstream'); }
                                } catch (ee) {}
                            } catch (e) { console.debug('[VP-CY] add edge failed', edgeId, e); }
                        }
                    }

                    try {
                        cy.nodes().forEach(n => { if (!seenNodeIds.has(n.id())) { try { console.debug('[VP-CY] node would be removed but kept to preserve position', n.id()); } catch (e) {} } });
                        cy.edges().forEach(ed => { if (!seenEdgeIds.has(ed.id())) { try { cy.remove(ed); } catch (e) {} } });
                    } catch (e) {}

                    // Final-pass: ensure upstream/downstream classes reflect current edge colors
                    try {
                        setTimeout(() => {
                            try {
                                cy.edges().forEach(ed => {
                                    try {
                                        const col = String(ed.data('color') || '').toLowerCase();
                                        if (col.includes('ff7f0e') || col.includes('255,127,14') || col.includes('255,127,14')) {
                                            if (!ed.hasClass('upstream')) { try { ed.addClass('upstream'); console.debug('[VP-CY] final-pass add upstream', ed.id()); } catch (ee) {} }
                                        } else {
                                            if (ed.hasClass('upstream')) { try { ed.removeClass('upstream'); } catch (ee) {} }
                                        }
                                        if (col.includes('1f77b4') || col.includes('31,119,180') || col.includes('30,119,180')) {
                                            if (!ed.hasClass('downstream')) { try { ed.addClass('downstream'); console.debug('[VP-CY] final-pass add downstream', ed.id()); } catch (ee) {} }
                                        } else {
                                            if (ed.hasClass('downstream')) { try { ed.removeClass('downstream'); } catch (ee) {} }
                                        }
                                    } catch (ee) {}
                                });
                            } catch (ee) { try { console.debug('[VP-CY] final-pass failed', ee); } catch (e) {} }
                        }, 0);
                    } catch (ee) {}

                    if (!window.__vp_initial_fit) { try { cy.fit(); } catch (e) {} window.__vp_initial_fit = true; }
                } catch (err) { console.error('[VP-CY]', err); }
            };
        })();
        </script>
    <style>
        html, body, #graph {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        #graph {
            width: 100%;
            min-height: 480px;
        }
    </style>
</head>
<body>
    <div id="graph"></div>

    <script>
    // update_graph(nodes, channels, node_info, stats)
    // nodes: array of node names
    // node_info: map node -> { node_type: "Rsu"|"Obu", upstream: { node_name: <string>, hops, mac } }
    window.update_graph = function(nodes, channels, node_info, stats) {
        try {
            // NOTE: do not destroy the Cytoscape instance on transient empty payloads.
            // Treat an explicit null as a request to remove the overlay; ignore undefined/empty arrays
            // to preserve user-drag positions and instance state across transient updates.
            if (nodes === null) {
                // explicit teardown
                try {
                    if (window.__vp_cy_instance) {
                        try { window.__vp_cy_instance.destroy(); } catch(e) {}
                        window.__vp_cy_instance = null;
                    }
                    const root = document.getElementById('__vp_cy_root');
                    if (root && root.parentNode) root.parentNode.removeChild(root);
                } catch (e) {}
                return;
            }
            if (!nodes || nodes.length === 0) {
                try { console.debug('[VP-CY] empty nodes payload; preserving existing graph state'); } catch (e) {}
                return;
            }

            // Separate RSUs and OBUs
            const rsus = [];
            const obus = [];
            for (const n of nodes) {
                const info = node_info && node_info[n];
                const t = info && info.node_type ? info.node_type : null;
                if (t && t.toLowerCase() === 'rsu') rsus.push(n);
                else obus.push(n);
            }

            // Compute positions
            const positions = {};
            // Place RSUs on a top row (y=1)
            const rsuCount = Math.max(1, rsus.length);
            for (let i = 0; i < rsus.length; i++) {
                const x = (i - (rsuCount - 1) / 2) * 2.0; // spacing
                positions[rsus[i]] = { x: x, y: 1.5 };
            }

            // Place OBUs in a circle below (centered under RSUs)
            const obuCount = obus.length;
            const radius = Math.max(1.5, 1.0 + obuCount / 6.0);
            for (let i = 0; i < obuCount; i++) {
                const angle = (2 * Math.PI * i) / Math.max(1, obuCount);
                const x = Math.cos(angle) * radius;
                const y = -1.0 + Math.sin(angle) * (radius * 0.25); // slightly elliptical
                positions[obus[i]] = { x: x, y: y };
            }

            // If there are RSUs but some OBUs have upstream pointing to a specific RSU, nudge their x toward that RSU for readability
            for (const n of obus) {
                const info = node_info && node_info[n];
                const up = info && info.upstream && info.upstream.node_name ? info.upstream.node_name : null;
                if (up && positions[up]) {
                    // move OBU x halfway toward upstream x
                    positions[n].x = (positions[n].x + positions[up].x) / 2.0;
                }
            }

            // Build traces for RSUs and OBUs
            const rsuX = [];
            const rsuY = [];
            const rsuText = [];
            for (const r of rsus) {
                rsuX.push(positions[r].x);
                rsuY.push(positions[r].y);
                rsuText.push(r);
            }

            const obuX = [];
            const obuY = [];
            const obuText = [];
            for (const o of obus) {
                obuX.push(positions[o].x);
                obuY.push(positions[o].y);
                obuText.push(o);
            }

            const data = [];

            // Normalize node_info into a plain object `din` so we can access keys/fields
            const din = {};
            if (node_info) {
                // If it's a Map-like (wasm sometimes produces Map), copy entries
                try {
                    if (typeof node_info.entries === 'function' && typeof node_info.forEach === 'function') {
                        // JS Map or similar
                        node_info.forEach((v, k) => {
                            din[k] = v;
                        });
                    } else if (typeof node_info === 'object') {
                        // plain object
                        Object.keys(node_info).forEach(k => (din[k] = node_info[k]));
                    }
                } catch (e) {
                    // Fallback: try to treat as plain object
                    try {
                        Object.keys(node_info).forEach(k => (din[k] = node_info[k]));
                    } catch (e2) {}
                }
            }

            // Lines for upstream edges
            const edgeTraces = [];
            const annotations = [];

            // Prefer iterating keys from normalized node_info (it reflects simulator state) but fall back to nodes
            const edgeNodeList = Object.keys(din).length > 0 ? Object.keys(din) : nodes;
            for (const n of edgeNodeList) {
                const info = din[n];
                const up = info && info.upstream && info.upstream.node_name ? info.upstream.node_name : null;
                if (up) {
                    if (positions[n] && positions[up]) {
                        edgeTraces.push({ x0: positions[n].x, y0: positions[n].y, x1: positions[up].x, y1: positions[up].y, from: n, to: up });
                    }
                }
            }

            // Prepare stats-driven visuals: normalize stats into plain object `dstat`
            const dstat = {};
            if (stats && typeof stats === 'object') {
                try {
                    // Map-like (wasm bindings may produce Map) -> use entries()
                    if (typeof stats.entries === 'function') {
                        for (const [k, v] of stats.entries()) {
                            dstat[k] = v;
                        }
                    } else if (typeof stats.forEach === 'function') {
                        // Map or object with forEach
                        stats.forEach((v, k) => { dstat[k] = v; });
                    } else {
                        // plain object
                        Object.keys(stats).forEach(k => { dstat[k] = stats[k]; });
                    }
                } catch (e) {
                    // fallback to Object.keys if iteration failed
                    try { Object.keys(stats).forEach(k => { dstat[k] = stats[k]; }); } catch (e2) { /* ignore */ }
                }
            }

            // Compute per-node delta bytes by comparing against last snapshot stored on window
            const last = window.__vp_last_stats || {};

            const getStatFor = (node) => {
                if (dstat && Object.prototype.hasOwnProperty.call(dstat, node)) return dstat[node];
                try {
                    if (stats && typeof stats.get === 'function') {
                        const v = stats.get(node);
                        if (typeof v !== 'undefined') return v;
                    }
                } catch (e) {}
                try {
                    if (stats && typeof stats[node] !== 'undefined') return stats[node];
                } catch (e) {}
                return undefined;
            };

            const readPartBytes = (part) => {
                if (!part) return { tx: 0, rx: 0 };
                try {
                    // Map-like (wasm Map)
                    if (typeof part.get === 'function') {
                        const tryGet = (keys) => {
                            for (const k of keys) {
                                try { const v = part.get(k); if (typeof v !== 'undefined' && v !== null) return v; } catch (e) {}
                            }
                            return undefined;
                        };
                        const tx = Number(tryGet(['tx','tx_bytes','tx_bytes_total','tx_bytes_sent','txBytes','tx_bytes_sent'])) || 0;
                        const rx = Number(tryGet(['rx','rx_bytes','rx_bytes_total','rx_bytes_recv','rxBytes','rx_bytes_recv'])) || 0;
                        return { tx, rx };
                    }

                    // Plain object: look for common numeric fields, else try to sum nested interfaces
                    if (typeof part === 'object') {
                        const pickObj = (obj, keys) => {
                            for (const k of keys) {
                                if (Object.prototype.hasOwnProperty.call(obj, k)) {
                                    const v = obj[k];
                                    if (typeof v === 'number') return v;
                                    if (typeof v === 'string' && v.match(/^\d+(\.\d+)?$/)) return Number(v);
                                }
                            }
                            return undefined;
                        };
                        const candidatesTx = ['tx','tx_bytes','tx_bytes_total','tx_bytes_sent','txBytes'];
                        const candidatesRx = ['rx','rx_bytes','rx_bytes_total','rx_bytes_recv','rxBytes'];
                        let tx = pickObj(part, candidatesTx);
                        let rx = pickObj(part, candidatesRx);
                        if (typeof tx !== 'undefined' || typeof rx !== 'undefined') {
                            return { tx: Number(tx || 0), rx: Number(rx || 0) };
                        }

                        // If object has nested interface-like entries, sum their tx/rx
                        let sumTx = 0, sumRx = 0, found = false;
                        for (const k of Object.keys(part)) {
                            try {
                                const v = part[k];
                                if (v && typeof v === 'object') {
                                    const p = readPartBytes(v);
                                    if (p && (p.tx || p.rx)) { sumTx += Number(p.tx || 0); sumRx += Number(p.rx || 0); found = true; }
                                }
                            } catch (e) {}
                        }
                        if (found) return { tx: sumTx, rx: sumRx };
                    }
                } catch (e) { try { console.debug('readPartBytes err', e, part); } catch (ee) {} }
                return { tx: 0, rx: 0 };
            };
            // friendly bits/sec formatter (input is bytes/sec)
            const bitsToHuman = (bytesPerSec) => {
                const bps = (Number(bytesPerSec) || 0) * 8;
                if (bps < 1000) return `${Math.round(bps)} bps`;
                const units = ['Kbps','Mbps','Gbps','Tbps'];
                let v = bps / 1000.0;
                let i = 0;
                while (v >= 1000 && i < units.length - 1) { v /= 1000; i++; }
                const fmt = v < 10 ? v.toFixed(1) : Math.round(v).toString();
                return `${fmt} ${units[i]}`;
            };
            // compute elapsed time since last snapshot to produce bytes/sec
            const now = Date.now();
            const last_ts = window.__vp_last_stats_ts || (now - 1000);
            const dt = Math.max(0.001, (now - last_ts) / 1000.0);

            const deltas = {}; // node -> { tx: bytes, rx: bytes, tx_bps, rx_bps }
            for (const node of Object.keys(positions)) {
                const cur = getStatFor(node);
                // stats payload may be [device_stats, tun_stats] or a single object; sum both entries when present
                let cur_tx = 0;
                let cur_rx = 0;
                try {
                    if (Array.isArray(cur)) {
                        for (const part of cur) {
                            const p = readPartBytes(part);
                            cur_tx += p.tx;
                            cur_rx += p.rx;
                        }
                    } else if (cur && typeof cur === 'object') {
                        const p = readPartBytes(cur);
                        cur_tx = p.tx;
                        cur_rx = p.rx;
                    }
                } catch (e) {
                    cur_tx = 0; cur_rx = 0;
                }
                const last_entry = last[node] || { tx: cur_tx, rx: cur_rx };
                const txd = Math.max(0, cur_tx - (last_entry.tx || 0));
                const rxd = Math.max(0, cur_rx - (last_entry.rx || 0));
                const tx_bps = txd / dt;
                const rx_bps = rxd / dt;
                deltas[node] = { tx: txd, rx: rxd, tx_bps, rx_bps };
            }

            // Save current as last for next call
            window.__vp_last_stats = {};
            for (const k of Object.keys(dstat)) {
                try {
                    const cur = dstat[k];
                    let total_tx = 0;
                    let total_rx = 0;
                    if (Array.isArray(cur)) {
                        for (const part of cur) {
                            const p = readPartBytes(part);
                            total_tx += p.tx;
                            total_rx += p.rx;
                        }
                    } else if (cur && typeof cur === 'object') {
                        const p = readPartBytes(cur);
                        total_tx = p.tx;
                        total_rx = p.rx;
                    }
                    window.__vp_last_stats[k] = { tx: total_tx, rx: total_rx };
                } catch (e) {
                    window.__vp_last_stats[k] = { tx: 0, rx: 0 };
                }
            }
            // update last timestamp
            window.__vp_last_stats_ts = now;

            // Build lightweight payload for Cytoscape instead of Plotly traces
            const nodes_arr = [];
            const edges_arr = [];
            try {
                // nodes (smaller defaults)
                window.__vp_seen_nodes = window.__vp_seen_nodes || {};
                Object.keys(positions).forEach(id => {
                    try {
                        const isRsu = rsus.indexOf(id) !== -1;
                        // smaller default sizes: RSU slightly bigger than OBU
                        const size = isRsu ? 18 : 12;
                        const type = din[id] && din[id].node_type ? din[id].node_type : null;
                        // DO NOT mark seen nodes here; let the renderer decide first-seen positioning
                        nodes_arr.push({ id: id, label: id, type: type, size: size, x: positions[id].x, y: positions[id].y });
                    } catch (e) {}
                });
                // edges derived from edgeTraces
                const mapSize = (b) => Math.min(30, Math.max(4, 2 + Math.log10(b + 1) * 6));
                for (const et of edgeTraces) {
                    try {
                        const from = et.from; const to = et.to;
                        const up = (deltas[from] && deltas[from].tx_bps) ? deltas[from].tx_bps : 0;
                        const down = (deltas[from] && deltas[from].rx_bps) ? deltas[from].rx_bps : 0;
                        // compute width using same log-scale contract as Rust: total = up+down
                        let bw = 1;
                        try {
                            const total = Math.max(0, up) + Math.max(0, down);
                            if (total <= 0) {
                                bw = 1;
                            } else {
                                const scale_log = 6.0;
                                const lv = Math.log10(total);
                                const frac = Math.max(0, Math.min(1, lv / scale_log));
                                const min_w = 1.0;
                                const max_w = 20.0;
                                bw = Math.max(1, Math.min(20, Math.round(min_w + frac * (max_w - min_w))));
                            }
                        } catch (e) { bw = 1; }
                        // If this edge corresponds to the immediate upstream for `from`, highlight it orange
                        let color;
                        try {
                            const isImmediateUp = (din && din[from] && din[from].upstream && String(din[from].upstream.node_name) === String(to));
                            if (isImmediateUp) {
                                // Use the same orange used for RSU markers for visual consistency
                                color = '#ff7f0e';
                            } else {
                                color = up > down ? 'rgba(200,30,30,0.9)' : (down > up ? 'rgba(30,100,200,0.9)' : 'rgba(120,120,120,1)');
                            }
                        } catch (e) { color = up > down ? 'rgba(200,30,30,0.9)' : (down > up ? 'rgba(30,100,200,0.9)' : 'rgba(120,120,120,1)'); }
                        edges_arr.push({ source: from, target: to, up_bps: up, down_bps: down, width: bw, color: color });
                    } catch (e) {}
                }
            } catch (e) { console.debug('[VP-CY] build cytoscape payload err', e); }

            // Send to cytoscape renderer
            try { if (typeof window.__vp_render_graph === 'function') window.__vp_render_graph(nodes_arr, edges_arr); } catch (e) { console.error('[VP-CY] call __vp_render_graph failed', e); }

            // RSU trace (square markers)
            if (rsuX.length > 0) {
                data.push({
                    x: rsuX,
                    y: rsuY,
                    mode: 'markers+text',
                    type: 'scatter',
                    text: rsuText,
                    textposition: 'top center',
                    marker: { symbol: 'square', size: 28, color: '#ff7f0e', line: { width: 1, color: '#333' } },
                    hoverinfo: 'text',
                    hovertext: rsuText.map(n => {
                        const d = deltas[n] || { tx: 0, rx: 0, tx_bps: 0, rx_bps: 0 };
                        return `${n} (RSU)\nup: ${bitsToHuman(d.tx_bps)}\ndown: ${bitsToHuman(d.rx_bps)}`;
                    })
                });
            }

            // OBU trace (circle markers)
            if (obuX.length > 0) {
                data.push({
                    x: obuX,
                    y: obuY,
                    mode: 'markers+text',
                    type: 'scatter',
                    text: obuText,
                    textposition: 'bottom center',
                    marker: { symbol: 'circle', size: 18, color: '#1f77b4', line: { width: 1, color: '#333' } },
                    hoverinfo: 'text',
                    hovertext: obuText.map(n => {
                        const d = deltas[n] || { tx: 0, rx: 0, tx_bps: 0, rx_bps: 0 };
                        return `${n} (OBU)\nup: ${bitsToHuman(d.tx_bps)}\ndown: ${bitsToHuman(d.rx_bps)}`;
                    })
                });
            }

            const layout = {
                xaxis: { showgrid: false, zeroline: false, showticklabels: false, fixedrange: true },
                yaxis: { showgrid: false, zeroline: false, showticklabels: false, fixedrange: true },
                margin: { l: 10, r: 10, t: 10, b: 10 },
                hovermode: 'closest',
                showlegend: false,
                annotations: annotations,
                height: Math.max(480, window.innerHeight - 20),
                // disable default drag mode box zoom
                dragmode: false,
            };

            // Remember nodes and channels for the parameter UI and refresh list
            try { window.__vp_nodes = Array.isArray(nodes) ? nodes.slice() : (nodes ? Object.keys(nodes) : []); } catch (e) { window.__vp_nodes = nodes || []; }
            try {
                let raw = [];
                if (Array.isArray(channels)) {
                    raw = channels.slice();
                } else if (channels && typeof channels.forEach === 'function') {
                    const tmp = [];
                    channels.forEach(c => tmp.push(c));
                    raw = tmp;
                } else if (channels && typeof channels === 'object') {
                    try { raw = Object.keys(channels).map(k => channels[k]); } catch (e2) { raw = []; }
                }
                // normalize endpoints using the runtime helper if available
                // expose raw for debugging
                try { window.__vp_raw_channels = raw.slice(); } catch (e) {}
                // Normalize raw entries into explicit directed channel objects.
                // For Map-like entries that appear to be undirected (keys are endpoint node names),
                // expand into both directions so the UI shows both A→B and B→A.
                const tempNorm = [];
                raw.forEach(c => {
                    try {
                        const ep = (typeof resolveChannelEndpoints === 'function') ? (resolveChannelEndpoints(c) || {}) : { from: (c && c.from), to: (c && c.to) };
                        const f = ep.from; const t = ep.to;
                        if (typeof f !== 'undefined' && f !== null && typeof t !== 'undefined' && t !== null) {
                            tempNorm.push({ from: f, to: t, __raw: c });
                            // If the raw entry is Map-like and its keys appear to be the endpoint names,
                            // also add the reverse direction to represent both channels.
                            try {
                                if (typeof c.keys === 'function') {
                                    const klist = [];
                                    for (const k of c.keys()) klist.push(k);
                                    if (klist.length >= 2) {
                                        const a = klist[0]; const b = klist[1];
                                        // if reverse isn't the same as forward, add reverse
                                        if (!(String(a) === String(f) && String(b) === String(t))) {
                                            tempNorm.push({ from: t, to: f, __raw: c });
                                        }
                                    }
                                }
                            } catch (e) {}
                        } else {
                            // fallback: if only one endpoint or unknown shape, attempt to glean keys
                            try {
                                if (typeof c.keys === 'function') {
                                    const klist = [];
                                    for (const k of c.keys()) klist.push(k);
                                    if (klist.length === 1) tempNorm.push({ from: klist[0], to: klist[0], __raw: c });
                                }
                            } catch (e) {}
                        }
                    } catch (e) { /* ignore malformed raw entries */ }
                });
                const norm = tempNorm.filter(x => (typeof x.from !== 'undefined' && x.from !== null) && (typeof x.to !== 'undefined' && x.to !== null));
                // Debug: show raw channel info for diagnostics
                try { console.debug('channels raw count', raw.length, 'sample', raw.slice(0,5)); } catch (e) {}
                // Expose edge traces for debugging
                try { window.__vp_edgeTraces = Array.isArray(edgeTraces) ? edgeTraces.slice() : (edgeTraces || null); } catch (e) {}
                // If there were no explicit channels provided, try to derive them from the plotted edge traces
                if ((!norm || norm.length === 0) && Array.isArray(edgeTraces) && edgeTraces.length > 0) {
                    const m = new Map();
                    edgeTraces.forEach(e => {
                        try {
                            const f = e.from; const t = e.to;
                            if (typeof f === 'undefined' && typeof t === 'undefined') return;
                            const k = `${f}→${t}`;
                            if (!m.has(k)) m.set(k, { from: f, to: t, __raw: e });
                        } catch (e2) { /* ignore */ }
                    });
                    const derived = Array.from(m.values());
                    // sort deterministically
                    derived.sort((a,b) => (String(a.from||'')).localeCompare(String(b.from||'')) || (String(a.to||'')).localeCompare(String(b.to||'')));
                    window.__vp_channels = derived;
                    try { window.__vp_norm_channels = derived.slice(); } catch (e) {}
                        try { console.debug('channels derived from edgeTraces', derived.length, derived.slice(0,6)); } catch (e) {}
                } else {
                    // dedupe and sort normalized channels for deterministic display
                    const uniq = [];
                    const seen = new Set();
                    norm.forEach(c => {
                        try {
                            const k = `${c.from}→${c.to}`;
                            if (!seen.has(k)) { seen.add(k); uniq.push(c); }
                        } catch (e) { /* ignore */ }
                    });
                    uniq.sort((a,b) => (String(a.from||'')).localeCompare(String(b.from||'')) || (String(a.to||'')).localeCompare(String(b.to||'')));
                    window.__vp_channels = uniq;
                    try { window.__vp_norm_channels = uniq.slice(); } catch (e) {}
                    try { console.debug('channels normalized/deduped', uniq.length, uniq.slice(0,6)); } catch (e) {}
                }
                // If we don't have the full directed mesh of channels for known nodes, synthesize it so the UI
                // allows editing any from->to pair. This is useful when the simulator only provides upstream edges
                // but the UI must allow setting parameters for both directions.
                try {
                    const nodesForMesh = Array.isArray(window.__vp_nodes) ? window.__vp_nodes.slice() : [];
                    if (nodesForMesh.length > 1) {
                        const expected = nodesForMesh.length * (nodesForMesh.length - 1);
                        if (!window.__vp_channels || window.__vp_channels.length < expected) {
                            const m = new Map();
                            (window.__vp_channels || []).forEach(c => {
                                try { const k = `${c.from}→${c.to}`; if (!m.has(k)) m.set(k, { from: c.from, to: c.to, __raw: c.__raw }); } catch (e) {}
                            });
                            for (const a of nodesForMesh) {
                                for (const b of nodesForMesh) {
                                    if (a === b) continue;
                                    const k = `${a}→${b}`;
                                    if (!m.has(k)) m.set(k, { from: a, to: b, __raw: null });
                                }
                            }
                            const all = Array.from(m.values());
                            all.sort((A,B) => (String(A.from||'')).localeCompare(String(B.from||'')) || (String(A.to||'')).localeCompare(String(B.to||'')));
                            window.__vp_channels = all;
                            try { window.__vp_norm_channels = all.slice(); } catch (e) {}
                            try { console.debug('channels expanded to full mesh', window.__vp_channels.length, window.__vp_channels.slice(0,12)); } catch (e) {}
                        }
                    }
                } catch (e) { /* ignore */ }
            } catch (e) { window.__vp_channels = []; }
        } catch (err) {
                                // Fallback: if coloring was applied but class toggle missed, detect by color and add appropriate class
        }
    };

    // Debug helper: dump current edges' color data and computed inline styles
    window.__vp_dump_edges = function() {
        try {
            const cy = window.__vp_cy_instance;
                                // Ensure the visual style and class persist even if something re-styles later
                                try {
                                    setTimeout(() => {
                                        try {
                                            const col = String(color || '').toLowerCase();
                                            if (existingE && existingE.length) {
                                                try { existingE.style('line-color', color); } catch (e) {}
                                                try { existingE.style('target-arrow-color', color); } catch (e) {}
                                                if (!existingE.hasClass('upstream') && (col.includes('ff7f0e') || col.includes('255,127,14'))) { try { existingE.addClass('upstream'); } catch (e) {} }
                                                if (!existingE.hasClass('downstream') && (col.includes('1f77b4') || col.includes('31,119,180') || col.includes('30,119,180'))) { try { existingE.addClass('downstream'); } catch (e) {} }
                                            }
                                        } catch (e) { try { console.debug('[VP-CY] reapply inline style failed', String(edgeId), e); } catch (ee) {} }
                                    }, 0);
                                } catch (ee) {}
            if (!cy) return console.warn('[VP-CY] no cy instance');
            const out = cy.edges().map(e => ({ id: e.id(), source: e.data('source'), target: e.data('target'), dataColor: e.data('color'), lineColorStyle: e.style('line-color'), arrowColorStyle: e.style('target-arrow-color'), lineOpacity: e.style('line-opacity') }));
            console.table(out);
            return out;
        } catch (e) { console.error('[VP-CY] dump edges failed', e); }
    };

    // Debug helper: list edge widths from data and computed style to verify thickness mapping
    window.__vp_dump_edge_widths = function() {
        try {
            const cy = window.__vp_cy_instance;
            if (!cy) return console.warn('[VP-CY] no cy instance');
            const out = cy.edges().map(e => ({ id: e.id(), source: e.data('source'), target: e.data('target'), total: e.data('__vp_total'), dataWidth: e.data('width'), bw: e.data('__vp_bw'), visualWidth: e.data('__vp_visual'), styleWidth: e.style('width'), arrowSize: e.style('arrow-scale') }));
            console.table(out);
            return out;
        } catch (e) { console.error('[VP-CY] dump edge widths failed', e); }
    };

    </script>
</body>
</html>
